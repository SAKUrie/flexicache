# FlexiCache 架构设计文档

## 📐 系统架构概览

FlexiCache 是一个运行在 RISC-V QEMU 环境中的动态代码管理系统原型，模拟了在异构内存系统中的代码搬运机制。

```
┌─────────────────────────────────────────────────────────────┐
│                    QEMU RISC-V (virt 板)                     │
│                                                               │
│  ┌───────────────────────────────────────────────────────┐  │
│  │            物理内存 (起始: 0x80000000)                 │  │
│  │                                                         │  │
│  │  ┌──────────────────────────────────────────────────┐ │  │
│  │  │  I-Mem (快速指令内存)                            │ │  │
│  │  │  0x80000000 - 0x800FFFFF (1MB)                   │ │  │
│  │  │  ┌────────────────────────────────────────────┐  │ │  │
│  │  │  │  运行时库代码 (flexicache.c)               │  │ │  │
│  │  │  │  - flexicache_init()                       │  │ │  │
│  │  │  │  - flexicache_load_block()                 │  │ │  │
│  │  │  │  - flexicache_evict_block()                │  │ │  │
│  │  │  └────────────────────────────────────────────┘  │ │  │
│  │  │  ┌────────────────────────────────────────────┐  │ │  │
│  │  │  │  动态缓存区 (从 0x80010000 开始)          │  │ │  │
│  │  │  │  - 运行时加载的用户代码                   │  │ │  │
│  │  │  └────────────────────────────────────────────┘  │ │  │
│  │  └──────────────────────────────────────────────────┘ │  │
│  │                                                         │  │
│  │  ┌──────────────────────────────────────────────────┐ │  │
│  │  │  DRAM (慢速主存)                                 │ │  │
│  │  │  0x80100000 - 0x801FFFFF (1MB)                   │ │  │
│  │  │  ┌────────────────────────────────────────────┐  │ │  │
│  │  │  │  用户代码 (.text.user)                     │  │ │  │
│  │  │  │  - fibonacci()                             │  │ │  │
│  │  │  │  - factorial()                             │  │ │  │
│  │  │  │  - sum_array()                             │  │ │  │
│  │  │  └────────────────────────────────────────────┘  │ │  │
│  │  │  ┌────────────────────────────────────────────┐  │ │  │
│  │  │  │  数据段 (.data, .bss)                      │  │ │  │
│  │  │  └────────────────────────────────────────────┘  │ │  │
│  │  │  ┌────────────────────────────────────────────┐  │ │  │
│  │  │  │  堆 (64KB)                                  │  │ │  │
│  │  │  └────────────────────────────────────────────┘  │ │  │
│  │  │  ┌────────────────────────────────────────────┐  │ │  │
│  │  │  │  栈 (64KB) ↓ 向下增长                       │  │ │  │
│  │  │  └────────────────────────────────────────────┘  │ │  │
│  │  └──────────────────────────────────────────────────┘ │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## 🔑 核心设计决策

### 1. 为什么用链接脚本而不是真实硬件？

**问题**: 真实的异构内存系统（如 I-Mem + DRAM）在 QEMU 中难以模拟。

**解决方案**: 使用链接脚本 `flexicache.ld` 将统一的物理内存"虚拟地"切分成两个区域：

```ld
MEMORY {
    IMEM (rwx) : ORIGIN = 0x80000000, LENGTH = 1M
    DRAM (rwx) : ORIGIN = 0x80100000, LENGTH = 1M
}
```

**优势**:
- ✅ 无需修改 QEMU 源码
- ✅ 可以用标准工具链编译
- ✅ 在报告中足以证明"运行时搬运逻辑"的可行性

### 2. 为什么用宏而不是二进制重写器？

**问题**: 完整的系统需要一个预处理器，自动在函数调用前插入 `flexicache_load_block()`。

**时间限制**: 3-4 天的工期无法实现完整的 ELF 二进制解析和修改器。

**MVP 方案**: 使用 C 宏 `CALL_MANAGED` 模拟：

```c
#define CALL_MANAGED(func, ...) ({ \
    flexicache_load_block((void*)func, 256); \
    func(__VA_ARGS__); \
})
```

**用法**:
```c
// 原始调用
int result = fibonacci(10);

// FlexiCache 管理的调用
int result = CALL_MANAGED(fibonacci, 10);
```

**未来扩展**: 可以用 Python + `pyelftools` 实现真正的二进制重写器。

### 3. 运行时库的职责

`runtime/flexicache.c` 是整个系统的核心，负责：

#### 3.1 初始化 (`flexicache_init`)
- 设置 I-Mem 分配器（从 `0x80010000` 开始可用）
- 初始化统计计数器
- 通过 UART 输出调试信息

#### 3.2 代码加载 (`flexicache_load_block`)

**流程图**:
```
开始
  ↓
检查函数地址是否在 I-Mem？
  ├─ 是 → 命中 ✓ → 返回 0
  └─ 否 → 未命中 ✗
           ↓
      检查地址是否在 DRAM？
           ├─ 否 → 错误 → 返回 -1
           └─ 是 ↓
           I-Mem 空间是否足够？
                ├─ 否 → 驱逐旧代码 (evict_block)
                └─ 是 ↓
           memcpy(target, src, size)
                ↓
           更新分配器指针
                ↓
           fence.i (刷新指令缓存)
                ↓
           更新统计信息
                ↓
           返回 0
```

#### 3.3 驱逐策略 (`flexicache_evict_block`)

**当前实现**: 简单清空整个 I-Mem 缓存区（除了运行时库）

**理由**: MVP 阶段优先验证"搬运逻辑"可行性

**未来改进**:
- LRU (Least Recently Used)
- FIFO (First In First Out)
- 基于函数调用频率的智能预取

## 📊 关键数据结构

### 统计信息 (`flexicache_stats_t`)

```c
typedef struct {
    uint32_t load_count;      // 加载次数
    uint32_t evict_count;     // 驱逐次数
    uint32_t hit_count;       // 命中次数
    uint32_t miss_count;      // 未命中次数
    uint32_t total_bytes;     // 总搬运字节数
} flexicache_stats_t;
```

### I-Mem 分配器 (`imem_allocator_t`)

```c
typedef struct {
    void *start;              // 当前可用空间起始地址
    size_t available;         // 剩余可用空间
} imem_allocator_t;
```

## 🔄 完整执行流程

### 启动阶段

```
1. QEMU 加载 flexicache_demo.elf
2. CPU 跳转到 _start (定义在 main.c)
3. _start 初始化栈指针: sp = 0x801FXXXX
4. _start 清空 BSS 段
5. 调用 flexicache_init()
   ├─ 初始化 I-Mem 分配器
   ├─ 清空统计信息
   └─ 打印初始化消息
```

### 函数调用阶段

```
用户代码: int result = CALL_MANAGED(fibonacci, 10);

展开宏:
  flexicache_load_block((void*)fibonacci, 256);
  ↓
  检查 fibonacci 地址 (0x801XXXXX) 是否在 I-Mem？
  ↓ 否 (首次调用)
  ↓
  分配 I-Mem 空间: target = 0x80010000
  ↓
  memcpy(0x80010000, 0x801XXXXX, 256)
  ↓
  fence.i (同步指令流)
  ↓
  miss_count++, load_count++, total_bytes += 256
  ↓
  返回 0
  
  fibonacci(10);  // 执行函数
```

### 再次调用同一函数

```
第二次: int result = CALL_MANAGED(fibonacci, 15);

flexicache_load_block((void*)fibonacci, 256);
  ↓
  检查 fibonacci 地址是否在 I-Mem？
  ↓ 是 (已加载)
  ↓
  hit_count++
  ↓
  直接返回 0 (无需搬运)

fibonacci(15);  // 执行函数
```

## 🛠️ 编译工具链

### GCC 编译选项详解

```makefile
CFLAGS = -march=rv32ima -mabi=ilp32 -O2 -g -Wall -Wextra
```

| 选项 | 含义 |
|------|------|
| `-march=rv32ima` | 目标架构：32位 RISC-V，支持整数(I)、乘法(M)、原子(A)指令 |
| `-mabi=ilp32` | ABI：整数、长整数、指针都是32位 |
| `-O2` | 优化级别：平衡性能和调试能力 |
| `-g` | 包含调试信息 |
| `-static` | 静态链接 |
| `-nostdlib` | 不链接标准库 |
| `-nostartfiles` | 不使用标准启动文件 |
| `-ffreestanding` | 裸机环境 |

### 链接选项

```makefile
LDFLAGS = -T scripts/flexicache.ld -Wl,-Map=flexicache_demo.map
```

- `-T scripts/flexicache.ld`: 使用自定义链接脚本
- `-Wl,-Map=...`: 生成内存映射文件（用于调试）

## 📏 内存布局详解

### I-Mem 区域 (0x80000000 - 0x800FFFFF)

| 偏移 | 大小 | 内容 | 说明 |
|------|------|------|------|
| 0x00000000 | ~64KB | 运行时库代码 | 固定，不会被驱逐 |
| 0x00010000 | ~960KB | 动态缓存区 | 用户代码的临时拷贝 |

### DRAM 区域 (0x80100000 - 0x801FFFFF)

| 段 | 大小 | 用途 |
|----|------|------|
| .text.user | 可变 | 用户函数的原始代码 |
| .rodata | 可变 | 只读数据（字符串常量等） |
| .data | 可变 | 已初始化全局变量 |
| .bss | 可变 | 未初始化全局变量 |
| .heap | 64KB | 动态内存分配 |
| .stack | 64KB | 函数调用栈 |

## 🧪 测试覆盖

### 测试用例

| 测试 | 目的 | 预期行为 |
|------|------|----------|
| `fibonacci(10)` | 首次调用 | 未命中 → 加载到 I-Mem |
| `fibonacci(15)` | 再次调用 | 命中 → 直接返回 |
| `factorial(8)` | 新函数 | 未命中 → 加载到 I-Mem |
| `sum_array()` | 带参数函数 | 未命中 → 加载到 I-Mem |

### 验证逻辑

```c
if (result1 == 55 && result2 == 610 && 
    result3 == 40320 && result4 == 55) {
    puts("✓ 所有测试通过！");
}
```

## 🚀 性能指标

### 理论分析

假设：
- I-Mem 访问延迟: 1 周期
- DRAM 访问延迟: 100 周期
- 代码搬运成本: N 字节 × 100 周期

**命中情况** (函数在 I-Mem):
```
总延迟 = 函数执行时间 (使用 I-Mem 速度)
```

**未命中情况** (首次调用):
```
总延迟 = 搬运时间 + 函数执行时间
       = (256 字节 × 100 周期) + 函数执行时间
       = 25,600 周期 + 函数执行时间
```

### 实测方法

可以通过 QEMU 的 `-icount` 选项统计指令数：

```bash
qemu-system-riscv32 -icount shift=0 -d exec,nochain ...
```

## 🔮 未来扩展

### 短期 (1-2 周)

- [ ] 实现真正的 LRU 缓存替换
- [ ] 添加 Python 脚本自动提取函数大小
- [ ] 支持多级缓存 (L1-I, L2)

### 中期 (1-2 月)

- [ ] 实现二进制重写器 (Python + pyelftools)
- [ ] 支持位置无关代码 (PIC)
- [ ] 添加硬件性能计数器模拟

### 长期 (3+ 月)

- [ ] 在真实 FPGA 板上验证
- [ ] 支持多线程/多核
- [ ] 机器学习驱动的智能预取

## 📖 相关概念

### RISC-V `fence.i` 指令

**作用**: 同步指令流和数据流

**场景**: 当我们修改代码段（如动态加载）后，必须执行 `fence.i`，否则 CPU 可能执行旧的缓存指令。

```c
void flexicache_flush_icache(void) {
    asm volatile ("fence.i" ::: "memory");
}
```

### 链接脚本中的 `ALIGN`

```ld
.text.user : ALIGN(4) { ... }
```

确保段起始地址是 4 字节对齐，RISC-V 要求指令必须对齐。

### QEMU virt 板

这是 QEMU 提供的通用虚拟开发板，特点：
- RAM 起始地址: `0x80000000`
- UART 地址: `0x10000000`
- 支持设备树 (Device Tree)

## 🎓 学习路径建议

1. **入门**: 运行示例 → 修改测试函数 → 观察统计信息
2. **进阶**: 阅读链接脚本 → 理解内存布局 → 修改内存大小
3. **深入**: 研究运行时库 → 实现 LRU 算法 → 添加性能分析
4. **高级**: GDB 调试 → 反汇编分析 → 修改编译选项优化

---

**设计理念**: 用最简单的方式验证核心思想，避免过早优化。

